import os

import pandas as pd
import streamlit as st

from utils.controlar_banco_de_dados import salvarTabela
from utils.mensagens import gerarMensagem
from utils.requisicoes import gerarTabelas

# Caminho absoluto at√© a raiz do projeto
BASE_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__)))
DATABASE_DIR = os.path.join(BASE_DIR, "database")
TABELAS_DIR = os.path.join(DATABASE_DIR, "tabelas")
RELATORIOS_DIR = os.path.join(BASE_DIR, "relatorios")

os.makedirs(DATABASE_DIR, exist_ok=True)
os.makedirs(TABELAS_DIR, exist_ok=True)
os.makedirs(RELATORIOS_DIR, exist_ok=True)

# Configurar p√°gina do streamlit
st.set_page_config(page_title="Relat√≥rio de Medidores", layout="wide")

# Definir titulo da p√°gina
st.title("Relat√≥rio de Medidores offline")

# Definir campo para fazer upload de arquivo
uploaded_file = st.file_uploader("Selecione o arquivo Excel (.xlsx)", type=["xlsx"])

# Usa arquivo da sess√£o, se j√° existir
if uploaded_file is not None:
    st.session_state["uploaded_file"] = uploaded_file
elif "uploaded_file" in st.session_state:
    uploaded_file = st.session_state["uploaded_file"]

# --- Bot√£o para gerar tabelas ---
if st.button("üîÑ Gerar Tabelas de Requisi√ß√µes"):
    with st.spinner("Gerando tabelas e atualizando dados..."):
        try:
            if gerarTabelas():  # <- chama sua fun√ß√£o
                st.success("Tabelas geradas e salvas com sucesso!")
                uploaded_file = os.path.join(TABELAS_DIR, 'sensores_atrasados.xlsx')
                st.session_state["uploaded_file"] = uploaded_file
        except Exception as e:
            st.error(f"Erro ao gerar tabelas: {e}")

# Verifica se o arquivo foi enviado
if uploaded_file is not None:
    # Salva o arquivo enviado na sess√£o
    if "df" not in st.session_state:
        st.session_state["df"] = pd.read_excel(uploaded_file, sheet_name="Sheet1")

    df = st.session_state["df"]

    salvarTabela(uploaded_file)

    try:
        # Remove a coluna OBS, se existir
        if 'OBS' in df.columns:
            df = df.drop(columns=['OBS'])

        # Remove a coluna OBS, se existir
        if 'Nome+Descri√ß√£o' in df.columns:
            df = df.drop(columns=['Nome+Descri√ß√£o'])

        # Filtra os dados a partir da coluna de dias offline
        dados_filtrados = df[df['Dias off.'] >= 2]

        #Informa a quantidade de registro encontrados
        st.success(f"{len(dados_filtrados)} registros encontrados com mais de 2 dias sem informa√ß√µes")

        # Configurar filtros
        # Filtro por Plataforma
        st.sidebar.header("Filtros")
        plataformas = sorted(df['Plataforma'].dropna().unique())
        plataforma_selecionada = st.sidebar.multiselect(
            "Filtrar por plataforma:", plataformas, default=plataformas)

        # Filtro por Data
        dias_min = st.sidebar.number_input("Qtd. dias iniciais", value=2, min_value=0, step=1)
        dias_max = int(df['Dias off.'].max())

        # Aplica filtros
        dados_filtrados = df[
            (df['Plataforma'].isin(plataforma_selecionada)) &
            (df['Dias off.'].between(dias_min, dias_max)) &
            (df['Dias off.'] > 0)]

        # Estat√≠sticas extras
        st.subheader("Resumo Geral")
        col1, col2, col3 = st.columns(3)
        col1.metric("Sensores com problemas", dados_filtrados['Descri√ß√£oSensor'].nunique())
        col2.metric("Usu√°rios com problemas", dados_filtrados['Email'].nunique())
        col3.metric("Maior n√∫mero de dias OFF", int(dados_filtrados['Dias off.'].max()))

        st.divider()

        #Exibe todos os medidores sem registro
        st.subheader("Medidores sem registros")
        st.dataframe(dados_filtrados, use_container_width=True)

        st.divider()

        # Agrupa os clientes por nome
        grupos = dados_filtrados.groupby('Nome')

        st.subheader("Detalhes por Usu√°rio")
        for nome, grupo_cliente in grupos:
            with st.expander(f"{nome}  -  {len(grupo_cliente)} registro(s)"):

                # Subgrupos dos cliente por plataforma
                subgrupos = grupo_cliente.groupby("Plataforma")

                for plataforma, subgrupo in subgrupos:
                    st.markdown(f"### üåê Plataforma: {plataforma} - {len(subgrupo)} registro(s)")
                    st.dataframe(subgrupo, use_container_width=True)

                    # Exibe a mensagem
                    st.code(gerarMensagem(subgrupo), language="markdown")

    except Exception as e:
        st.error(f"Erro ao processar planilha: {e}")
else:
    st.info("Fa√ßa o upload do arquivo Excel para visualizar os dados.")
